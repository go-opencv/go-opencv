%module gcv_core
%include "std_vector.i"

%{
#include "opencv2/core/types_c.h"
#include "opencv2/core/version.hpp"
#include "opencv2/core/core.hpp"
%}

/* Classes defined in core.hpp */
namespace cv {

   template<typename _Tp> class Size_;
   template<typename _Tp> class Point_;
   template<typename _Tp> class Rect_;
   template<typename _Tp, int cn> class Vec;

   //////////////////////////////// Point_ ////////////////////////////////

   /*!
   template 2D point class.

   The class defines a point in 2D space. Data type of the point coordinates is specified
   as a template parameter. There are a few shorter aliases available for user convenience.
   See cv::Point, cv::Point2i, cv::Point2f and cv::Point2d.
   */
   template<typename _Tp> class Point_
   {
   public:
      typedef _Tp value_type;

      // various constructors
      Point_();
      Point_(_Tp _x, _Tp _y);
      Point_(const Point_& pt);
      Point_(const CvPoint& pt);
      Point_(const CvPoint2D32f& pt);
      Point_(const Size_<_Tp>& sz);
      Point_(const Vec<_Tp, 2>& v);

      Point_& operator = (const Point_& pt);
      //! conversion to another data type
      template<typename _Tp2> operator Point_<_Tp2>() const;

      //! conversion to the old-style C structures
      operator CvPoint() const;
      operator CvPoint2D32f() const;
      operator Vec<_Tp, 2>() const;

      //! dot product
      _Tp dot(const Point_& pt) const;
      //! dot product computed in double-precision arithmetics
      double ddot(const Point_& pt) const;
      //! cross-product
      double cross(const Point_& pt) const;
      //! checks whether the point is inside the specified rectangle
      bool inside(const Rect_<_Tp>& r) const;

      _Tp x, y; //< the point coordinates
   };

   /*!
   template 3D point class.

   The class defines a point in 3D space. Data type of the point coordinates is specified
   as a template parameter.

   \see cv::Point3i, cv::Point3f and cv::Point3d
   */
   template<typename _Tp> class Point3_
   {
   public:
      typedef _Tp value_type;

      // various constructors
      Point3_();
      Point3_(_Tp _x, _Tp _y, _Tp _z);
      Point3_(const Point3_& pt);
      explicit Point3_(const Point_<_Tp>& pt);
      Point3_(const CvPoint3D32f& pt);
      Point3_(const Vec<_Tp, 3>& v);

      Point3_& operator = (const Point3_& pt);
      //! conversion to another data type
      template<typename _Tp2> operator Point3_<_Tp2>() const;
      //! conversion to the old-style CvPoint...
      operator CvPoint3D32f() const;
      //! conversion to cv::Vec<>
      operator Vec<_Tp, 3>() const;

      //! dot product
      _Tp dot(const Point3_& pt) const;
      //! dot product computed in double-precision arithmetics
      double ddot(const Point3_& pt) const;
      //! cross product of the 2 3D points
      Point3_ cross(const Point3_& pt) const;

      _Tp x, y, z; //< the point coordinates
   };

   //////////////////////////////// Size_ ////////////////////////////////

   /*!
   The 2D size class

   The class represents the size of a 2D rectangle, image size, matrix size etc.
   Normally, cv::Size ~ cv::Size_<int> is used.
   */
   template<typename _Tp> class Size_
   {
   public:
      typedef _Tp value_type;

      //! various constructors
      Size_();
      Size_(_Tp _width, _Tp _height);
      Size_(const Size_& sz);
      Size_(const CvSize& sz);
      Size_(const CvSize2D32f& sz);
      Size_(const Point_<_Tp>& pt);

      Size_& operator = (const Size_& sz);
      //! the area (width*height)
      _Tp area() const;

      //! conversion of another data type.
      template<typename _Tp2> operator Size_<_Tp2>() const;

      //! conversion to the old-style OpenCV types
      operator CvSize() const;
      operator CvSize2D32f() const;

      _Tp width, height; // the width and the height
   };

   //////////////////////////////// Rect_ ////////////////////////////////

   /*!
   The 2D up-right rectangle class

   The class represents a 2D rectangle with coordinates of the specified data type.
   Normally, cv::Rect ~ cv::Rect_<int> is used.
   */
   template<typename _Tp> class Rect_
   {
   public:
      typedef _Tp value_type;

      //! various constructors
      Rect_();
      Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);
      Rect_(const Rect_& r);
      Rect_(const CvRect& r);
      Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);
      Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);

      Rect_& operator = ( const Rect_& r );
      //! the top-left corner
      Point_<_Tp> tl() const;
      //! the bottom-right corner
      Point_<_Tp> br() const;

      //! size (width, height) of the rectangle
      Size_<_Tp> size() const;
      //! area (width*height) of the rectangle
      _Tp area() const;

      //! conversion to another data type
      template<typename _Tp2> operator Rect_<_Tp2>() const;
      //! conversion to the old-style CvRect
      operator CvRect() const;

      //! checks whether the rectangle contains the point
      bool contains(const Point_<_Tp>& pt) const;

      _Tp x, y, width, height; //< the top-left corner, as well as width and height of the rectangle
   };


   %template(GcvSize2i) Size_<int>;
   %template(GcvSize2d) Size_<double>;
   %template(GcvSize2f) Size_<float>;

   %template(GcvRect) Rect_<int>;

   %template(GcvPoint2i) Point_<int>;
   %template(GcvPoint2f) Point_<float>;
   %template(GcvPoint2d) Point_<double>;

   %template(GcvPoint3i) Point3_<int>;
   %template(GcvPoint3f) Point3_<float>;
   %template(GcvPoint3d) Point3_<double>;
}

/* Additional STL types */
namespace std {
   %template(GcvPoint3fVector) vector<cv::Point3f>;
   %template(GcvPoint2fVector) vector<cv::Point2f>;

   %template(GcvIntVector) vector<int>;
   %template(GcvFloatVector) vector<float>;
};
